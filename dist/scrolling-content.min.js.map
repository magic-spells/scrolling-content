{"version":3,"file":"scrolling-content.min.js","sources":["../src/scrolling-content.js"],"sourcesContent":["// <scrolling-track>\nclass ScrollingTrack extends HTMLElement {\n  connectedCallback() {\n    const _ = this;\n    _.style.display = 'flex';\n    _.style.flexWrap = 'nowrap';\n    _.style.alignItems = 'center';\n    _.style.gap = 'var(--scrolling-content-gap, 1rem)';\n    _.style.cursor = 'pointer';\n    _.style.touchAction = 'pan-y';\n    if (_.getAttribute('gap')) _.style.gap = `${parseFloat(_.getAttribute('gap'))}px`;\n  }\n}\ncustomElements.define('scrolling-track', ScrollingTrack);\n\n// <scrolling-item>\nclass ScrollingItem extends HTMLElement {\n  connectedCallback() {\n    const _ = this;\n    _.style.display = 'flex';\n    _.style.alignItems = 'center';\n    _.style.gap = 'var(--scrolling-content-gap, 1rem)';\n    if (_.getAttribute('pad')) _.style.padding = `${parseFloat(_.getAttribute('pad'))}px`;\n  }\n}\ncustomElements.define('scrolling-item', ScrollingItem);\n\n// <scrolling-content>\nclass ScrollingContent extends HTMLElement {\n  static get observedAttributes() {\n    return ['mobile-speed', 'desktop-speed', 'breakpoint'];\n  }\n\n  constructor() {\n    super();\n    const _ = this;\n    _.track = null;\n    _.items = [];\n    _.mobileSpeed = 40;\n    _.desktopSpeed = 60;\n    _.breakpoint = 767;\n    _.isRunning = false;\n    _.isHoverPaused = false;\n    _.isDragging = false;\n    _.prevTime = 0;\n    _.offsetX = 0;\n    _.dragStartX = 0;\n    _.dragStartY = 0; // track initial Y position for direction detection\n    _.startOffset = 0;\n    _.containerWidth = 0;\n    _.loopDistance = 0; // distance to move before wrapping back to start\n    _.rafId = null;\n    _.recalculateLayout = _.throttle(() => _.doRecalculateLayout(), 5);\n    _.resizeHandler = () => _.handleResize();\n    _.focusHandler = () => _.handleFocus();\n    _.touchDirection = 0; // 0: unknown, 1: horizontal, -1: vertical\n    _.directionThreshold = 3; // pixels of movement before determining direction\n  }\n\n  throttle(func, delay) {\n    let timeoutId;\n    return (...args) => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => func.apply(this, args), delay);\n    };\n  }\n\n  connectedCallback() {\n    const _ = this;\n    _.initElements();\n    _.readAttributes();\n    // using requestAnimationFrame here causes a\n    // width calculation error - so don't use it here!\n    setTimeout(() => {\n      _.checkTrackWidth();\n      _.attachEvents();\n      _.start();\n    }, 5);\n  }\n\n  attributeChangedCallback(name, oldV, newV) {\n    const _ = this;\n    if (oldV === newV) return;\n    _.readAttributes();\n    if (!_.isHoverPaused && !_.isDragging) {\n      _.stop();\n      _.start();\n    }\n  }\n\n  initElements() {\n    const _ = this;\n    _.style.overflow = 'hidden';\n    _.track = _.querySelector('scrolling-track');\n    if (!_.track) {\n      _.track = document.createElement('scrolling-track');\n      while (_.firstChild) _.track.appendChild(_.firstChild);\n      _.appendChild(_.track);\n    }\n\n    // Check if content is already wrapped in scrolling-item\n    const existingItem = _.track.querySelector('scrolling-item');\n    if (!existingItem) {\n      // Wrap all track content in a single scrolling-item\n      const item = document.createElement('scrolling-item');\n      while (_.track.firstChild) {\n        item.appendChild(_.track.firstChild);\n      }\n      _.track.appendChild(item);\n    }\n\n    _.items = Array.from(_.track.children);\n    Object.assign(_.track.style, {\n      display: 'flex',\n      willChange: 'transform',\n    });\n    _.containerWidth = _.getBoundingClientRect().width;\n  }\n\n  readAttributes() {\n    const _ = this;\n    const getNum = (attr, fallback) =>\n      isNaN(parseFloat(_.getAttribute(attr))) ? fallback : parseFloat(_.getAttribute(attr));\n    _.mobileSpeed = getNum('mobile-speed', _.mobileSpeed);\n    _.desktopSpeed = getNum('desktop-speed', _.desktopSpeed);\n    _.breakpoint = getNum('breakpoint', _.breakpoint);\n  }\n\n  /**\n   * duplicates items until track is at least 200% of container width\n   */\n  checkTrackWidth() {\n    const _ = this;\n    if (!_.items.length) return;\n\n    // get the width of the first item (since all items are the same)\n    const itemWidth = _.items[0].getBoundingClientRect().width;\n\n    // get gap from CSS variable or track style\n    const computedStyle = getComputedStyle(_.track);\n    const gap = parseFloat(computedStyle.gap) || 0;\n\n    // store the distance we need to move before wrapping back to start\n    // this is the width of one item plus one gap\n    _.loopDistance = itemWidth + gap;\n\n    // calculate how many items we need to fill 200% of container\n    const itemsNeeded = Math.ceil((_.containerWidth * 2) / itemWidth) + 1;\n\n    // only duplicate if we need more items\n    const currentCount = _.items.length;\n    for (let i = currentCount; i < itemsNeeded; i++) {\n      const clone = _.items[0].cloneNode(true);\n      _.track.appendChild(clone);\n    }\n\n    // update items array with all children\n    _.items = Array.from(_.track.children);\n  }\n\n  attachEvents() {\n    const _ = this;\n    _.addEventListener('mouseenter', () => {\n      _.isHoverPaused = true;\n      _.stop();\n    });\n    _.addEventListener('mouseleave', () => {\n      _.isHoverPaused = false;\n      if (!_.isDragging) _.start();\n    });\n\n    // Touch events for better mobile support\n    _.track.addEventListener('touchstart', (e) => _.onTouchStart(e), { passive: false });\n    _.track.addEventListener('touchmove', (e) => _.onTouchMove(e), { passive: false });\n    _.track.addEventListener('touchend', (e) => _.onTouchEnd(e));\n    _.track.addEventListener('touchcancel', (e) => _.onTouchEnd(e));\n\n    // Pointer events for desktop/mouse\n    _.track.addEventListener('pointerdown', (e) => _.onPointerDown(e));\n    window.addEventListener('pointermove', (e) => _.onPointerMove(e));\n    window.addEventListener('pointerup', (e) => _.onPointerUp(e));\n    window.addEventListener('pointercancel', (e) => _.onPointerUp(e));\n    window.addEventListener('resize', _.resizeHandler);\n    window.addEventListener('focus', _.focusHandler);\n  }\n\n  start() {\n    const _ = this;\n    if (_.isRunning) return;\n    _.isRunning = true;\n    _.prevTime = performance.now();\n    _.rafId = requestAnimationFrame((ts) => _.tick(ts));\n  }\n\n  stop() {\n    const _ = this;\n    if (!_.isRunning) return;\n    cancelAnimationFrame(_.rafId);\n    _.isRunning = false;\n    _.rafId = null;\n  }\n\n  /**\n   * main animation loop\n   * @param {number} ts - timestamp from requestAnimationFrame\n   */\n  tick(ts) {\n    const _ = this;\n    if (!_.isRunning) return;\n\n    // calculate time delta\n    const delta = (ts - _.prevTime) / 1000;\n    _.prevTime = ts;\n\n    // move left by speed * delta\n    _.offsetX -= _.getCurrentSpeed() * delta;\n\n    // wrap around when we've moved past one complete loop distance\n    // this creates the infinite loop illusion\n    if (_.offsetX <= -_.loopDistance) {\n      _.offsetX += _.loopDistance;\n    }\n\n    // apply the transform\n    _.track.style.transform = `translateX(${_.offsetX}px)`;\n\n    // continue animation\n    _.rafId = requestAnimationFrame((t) => _.tick(t));\n  }\n\n  getCurrentSpeed() {\n    return window.innerWidth <= this.breakpoint ? this.mobileSpeed : this.desktopSpeed;\n  }\n\n  onTouchStart(e) {\n    const _ = this;\n    if (e.touches.length !== 1) return; // only handle single touch\n\n    _.isDragging = true;\n    _.dragStartX = e.touches[0].screenX;\n    _.dragStartY = e.touches[0].screenY;\n    _.startOffset = _.offsetX;\n    _.touchDirection = 0; // reset direction\n    _.stop();\n  }\n\n  onTouchMove(e) {\n    const _ = this;\n    if (!_.isDragging || e.touches.length !== 1) return;\n\n    // if already determined to be horizontal, prevent default and scroll\n    if (_.touchDirection === 1) {\n      e.preventDefault();\n      const diffX = e.touches[0].screenX - _.dragStartX;\n\n      _.offsetX = _.startOffset + diffX;\n      while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n      while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n      _.track.style.transform = `translateX(${_.offsetX}px)`;\n      return;\n    }\n\n    // calculate movement distances to determine direction\n    const deltaX = Math.abs(_.dragStartX - e.touches[0].screenX);\n    const deltaY = Math.abs(_.dragStartY - e.touches[0].screenY);\n\n    // determine direction with bias toward horizontal (like your carousel)\n    if (\n      deltaX * 1.15 > deltaY &&\n      (deltaX > _.directionThreshold || deltaY > _.directionThreshold)\n    ) {\n      // horizontal movement detected\n      _.touchDirection = 1;\n      e.preventDefault();\n      return;\n    } else if (deltaY > _.directionThreshold && deltaX <= deltaY) {\n      // vertical movement detected - cancel drag and allow page scroll\n      _.touchDirection = -1;\n      _.isDragging = false;\n      if (!_.isHoverPaused) _.start();\n      return;\n    }\n\n    // direction not yet determined - prevent default to avoid premature page scroll\n    e.preventDefault();\n  }\n\n  onTouchEnd() {\n    const _ = this;\n    if (!_.isDragging) return;\n    _.isDragging = false;\n    _.touchDirection = 0;\n    if (!_.isHoverPaused) _.start();\n  }\n\n  onPointerDown(e) {\n    const _ = this;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n\n    _.isDragging = true;\n    _.dragStartX = e.clientX;\n    _.dragStartY = e.clientY; // store initial Y position\n    _.startOffset = _.offsetX;\n    _.touchDirection = 0; // reset direction detection\n    _.stop();\n    _.track.setPointerCapture(e.pointerId);\n  }\n\n  onPointerMove(e) {\n    const _ = this;\n    if (!_.isDragging) return;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n\n    // calculate movement distances\n    const diffX = e.clientX - _.dragStartX;\n\n    _.offsetX = _.startOffset + diffX;\n\n    // normalize offset to stay within bounds\n    while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n    while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n\n    _.track.style.transform = `translateX(${_.offsetX}px)`;\n  }\n\n  onPointerUp(e) {\n    const _ = this;\n    if (!_.isDragging) return;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n\n    _.isDragging = false;\n    _.touchDirection = 0; // reset direction\n    try {\n      _.track.releasePointerCapture(e.pointerId);\n    } catch {\n      // Ignore errors if pointer capture was already released\n    }\n    if (!_.isHoverPaused) _.start();\n  }\n\n  doRecalculateLayout() {\n    const _ = this;\n    setTimeout(() => {\n      _.containerWidth = _.getBoundingClientRect().width;\n      _.checkTrackWidth();\n\n      // normalize offset position with new dimensions\n      _.offsetX = _.offsetX % _.loopDistance;\n      while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n      while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n\n      _.track.style.transform = `translateX(${_.offsetX}px)`;\n\n      // restart animation if not paused by user interaction\n      if (!_.isHoverPaused && !_.isDragging) {\n        _.start();\n      }\n    }, 1);\n  }\n\n  handleResize() {\n    const _ = this;\n    const newW = _.getBoundingClientRect().width;\n    if (newW === _.containerWidth) return;\n    _.recalculateLayout();\n  }\n\n  handleFocus() {\n    this.recalculateLayout();\n  }\n}\ncustomElements.define('scrolling-content', ScrollingContent);\n"],"names":["ScrollingTrack","HTMLElement","connectedCallback","_","this","style","display","flexWrap","alignItems","gap","cursor","touchAction","getAttribute","parseFloat","customElements","define","ScrollingItem","padding","ScrollingContent","observedAttributes","constructor","super","track","items","mobileSpeed","desktopSpeed","breakpoint","isRunning","isHoverPaused","isDragging","prevTime","offsetX","dragStartX","dragStartY","startOffset","containerWidth","loopDistance","rafId","recalculateLayout","throttle","doRecalculateLayout","resizeHandler","handleResize","focusHandler","handleFocus","touchDirection","directionThreshold","func","delay","timeoutId","args","clearTimeout","setTimeout","apply","initElements","readAttributes","checkTrackWidth","attachEvents","start","attributeChangedCallback","name","oldV","newV","stop","overflow","querySelector","document","createElement","firstChild","appendChild","item","Array","from","children","Object","assign","willChange","getBoundingClientRect","width","getNum","attr","fallback","isNaN","length","itemWidth","computedStyle","getComputedStyle","itemsNeeded","Math","ceil","i","clone","cloneNode","addEventListener","e","onTouchStart","passive","onTouchMove","onTouchEnd","onPointerDown","window","onPointerMove","onPointerUp","performance","now","requestAnimationFrame","ts","tick","cancelAnimationFrame","delta","getCurrentSpeed","transform","t","innerWidth","touches","screenX","screenY","preventDefault","diffX","deltaX","abs","deltaY","pointerType","clientX","clientY","setPointerCapture","pointerId","releasePointerCapture"],"mappings":"2FACA,MAAMA,uBAAuBC,YAC3B,iBAAAC,GACE,MAAMC,EAAIC,KACVD,EAAEE,MAAMC,QAAU,OAClBH,EAAEE,MAAME,SAAW,SACnBJ,EAAEE,MAAMG,WAAa,SACrBL,EAAEE,MAAMI,IAAM,qCACdN,EAAEE,MAAMK,OAAS,UACjBP,EAAEE,MAAMM,YAAc,QAClBR,EAAES,aAAa,SAAQT,EAAEE,MAAMI,IAAM,GAAGI,WAAWV,EAAES,aAAa,YACvE,EAEHE,eAAeC,OAAO,kBAAmBf,gBAGzC,MAAMgB,sBAAsBf,YAC1B,iBAAAC,GACE,MAAMC,EAAIC,KACVD,EAAEE,MAAMC,QAAU,OAClBH,EAAEE,MAAMG,WAAa,SACrBL,EAAEE,MAAMI,IAAM,qCACVN,EAAES,aAAa,SAAQT,EAAEE,MAAMY,QAAU,GAAGJ,WAAWV,EAAES,aAAa,YAC3E,EAEHE,eAAeC,OAAO,iBAAkBC,eAGxC,MAAME,yBAAyBjB,YAC7B,6BAAWkB,GACT,MAAO,CAAC,eAAgB,gBAAiB,aAC1C,CAED,WAAAC,GACEC,QACA,MAAMlB,EAAIC,KACVD,EAAEmB,MAAQ,KACVnB,EAAEoB,MAAQ,GACVpB,EAAEqB,YAAc,GAChBrB,EAAEsB,aAAe,GACjBtB,EAAEuB,WAAa,IACfvB,EAAEwB,WAAY,EACdxB,EAAEyB,eAAgB,EAClBzB,EAAE0B,YAAa,EACf1B,EAAE2B,SAAW,EACb3B,EAAE4B,QAAU,EACZ5B,EAAE6B,WAAa,EACf7B,EAAE8B,WAAa,EACf9B,EAAE+B,YAAc,EAChB/B,EAAEgC,eAAiB,EACnBhC,EAAEiC,aAAe,EACjBjC,EAAEkC,MAAQ,KACVlC,EAAEmC,kBAAoBnC,EAAEoC,UAAS,IAAMpC,EAAEqC,uBAAuB,GAChErC,EAAEsC,cAAgB,IAAMtC,EAAEuC,eAC1BvC,EAAEwC,aAAe,IAAMxC,EAAEyC,cACzBzC,EAAE0C,eAAiB,EACnB1C,EAAE2C,mBAAqB,CACxB,CAED,QAAAP,CAASQ,EAAMC,GACb,IAAIC,EACJ,MAAO,IAAIC,KACTC,aAAaF,GACbA,EAAYG,YAAW,IAAML,EAAKM,MAAMjD,KAAM8C,IAAOF,GAExD,CAED,iBAAA9C,GACE,MAAMC,EAAIC,KACVD,EAAEmD,eACFnD,EAAEoD,iBAGFH,YAAW,KACTjD,EAAEqD,kBACFrD,EAAEsD,eACFtD,EAAEuD,UACD,EACJ,CAED,wBAAAC,CAAyBC,EAAMC,EAAMC,GACnC,MAAM3D,EAAIC,KACNyD,IAASC,IACb3D,EAAEoD,iBACGpD,EAAEyB,eAAkBzB,EAAE0B,aACzB1B,EAAE4D,OACF5D,EAAEuD,SAEL,CAED,YAAAJ,GACE,MAAMnD,EAAIC,KAGV,GAFAD,EAAEE,MAAM2D,SAAW,SACnB7D,EAAEmB,MAAQnB,EAAE8D,cAAc,oBACrB9D,EAAEmB,MAAO,CAEZ,IADAnB,EAAEmB,MAAQ4C,SAASC,cAAc,mBAC1BhE,EAAEiE,YAAYjE,EAAEmB,MAAM+C,YAAYlE,EAAEiE,YAC3CjE,EAAEkE,YAAYlE,EAAEmB,MACjB,CAID,IADqBnB,EAAEmB,MAAM2C,cAAc,kBACxB,CAEjB,MAAMK,EAAOJ,SAASC,cAAc,kBACpC,KAAOhE,EAAEmB,MAAM8C,YACbE,EAAKD,YAAYlE,EAAEmB,MAAM8C,YAE3BjE,EAAEmB,MAAM+C,YAAYC,EACrB,CAEDnE,EAAEoB,MAAQgD,MAAMC,KAAKrE,EAAEmB,MAAMmD,UAC7BC,OAAOC,OAAOxE,EAAEmB,MAAMjB,MAAO,CAC3BC,QAAS,OACTsE,WAAY,cAEdzE,EAAEgC,eAAiBhC,EAAE0E,wBAAwBC,KAC9C,CAED,cAAAvB,GACE,MAAMpD,EAAIC,KACJ2E,EAAS,CAACC,EAAMC,IACpBC,MAAMrE,WAAWV,EAAES,aAAaoE,KAAUC,EAAWpE,WAAWV,EAAES,aAAaoE,IACjF7E,EAAEqB,YAAcuD,EAAO,eAAgB5E,EAAEqB,aACzCrB,EAAEsB,aAAesD,EAAO,gBAAiB5E,EAAEsB,cAC3CtB,EAAEuB,WAAaqD,EAAO,aAAc5E,EAAEuB,WACvC,CAKD,eAAA8B,GACE,MAAMrD,EAAIC,KACV,IAAKD,EAAEoB,MAAM4D,OAAQ,OAGrB,MAAMC,EAAYjF,EAAEoB,MAAM,GAAGsD,wBAAwBC,MAG/CO,EAAgBC,iBAAiBnF,EAAEmB,OACnCb,EAAMI,WAAWwE,EAAc5E,MAAQ,EAI7CN,EAAEiC,aAAegD,EAAY3E,EAG7B,MAAM8E,EAAcC,KAAKC,KAAyB,EAAnBtF,EAAEgC,eAAsBiD,GAAa,EAIpE,IAAK,IAAIM,EADYvF,EAAEoB,MAAM4D,OACFO,EAAIH,EAAaG,IAAK,CAC/C,MAAMC,EAAQxF,EAAEoB,MAAM,GAAGqE,WAAU,GACnCzF,EAAEmB,MAAM+C,YAAYsB,EACrB,CAGDxF,EAAEoB,MAAQgD,MAAMC,KAAKrE,EAAEmB,MAAMmD,SAC9B,CAED,YAAAhB,GACE,MAAMtD,EAAIC,KACVD,EAAE0F,iBAAiB,cAAc,KAC/B1F,EAAEyB,eAAgB,EAClBzB,EAAE4D,UAEJ5D,EAAE0F,iBAAiB,cAAc,KAC/B1F,EAAEyB,eAAgB,EACbzB,EAAE0B,YAAY1B,EAAEuD,WAIvBvD,EAAEmB,MAAMuE,iBAAiB,cAAeC,GAAM3F,EAAE4F,aAAaD,IAAI,CAAEE,SAAS,IAC5E7F,EAAEmB,MAAMuE,iBAAiB,aAAcC,GAAM3F,EAAE8F,YAAYH,IAAI,CAAEE,SAAS,IAC1E7F,EAAEmB,MAAMuE,iBAAiB,YAAaC,GAAM3F,EAAE+F,WAAWJ,KACzD3F,EAAEmB,MAAMuE,iBAAiB,eAAgBC,GAAM3F,EAAE+F,WAAWJ,KAG5D3F,EAAEmB,MAAMuE,iBAAiB,eAAgBC,GAAM3F,EAAEgG,cAAcL,KAC/DM,OAAOP,iBAAiB,eAAgBC,GAAM3F,EAAEkG,cAAcP,KAC9DM,OAAOP,iBAAiB,aAAcC,GAAM3F,EAAEmG,YAAYR,KAC1DM,OAAOP,iBAAiB,iBAAkBC,GAAM3F,EAAEmG,YAAYR,KAC9DM,OAAOP,iBAAiB,SAAU1F,EAAEsC,eACpC2D,OAAOP,iBAAiB,QAAS1F,EAAEwC,aACpC,CAED,KAAAe,GACE,MAAMvD,EAAIC,KACND,EAAEwB,YACNxB,EAAEwB,WAAY,EACdxB,EAAE2B,SAAWyE,YAAYC,MACzBrG,EAAEkC,MAAQoE,uBAAuBC,GAAOvG,EAAEwG,KAAKD,KAChD,CAED,IAAA3C,GACE,MAAM5D,EAAIC,KACLD,EAAEwB,YACPiF,qBAAqBzG,EAAEkC,OACvBlC,EAAEwB,WAAY,EACdxB,EAAEkC,MAAQ,KACX,CAMD,IAAAsE,CAAKD,GACH,MAAMvG,EAAIC,KACV,IAAKD,EAAEwB,UAAW,OAGlB,MAAMkF,GAASH,EAAKvG,EAAE2B,UAAY,IAClC3B,EAAE2B,SAAW4E,EAGbvG,EAAE4B,SAAW5B,EAAE2G,kBAAoBD,EAI/B1G,EAAE4B,UAAY5B,EAAEiC,eAClBjC,EAAE4B,SAAW5B,EAAEiC,cAIjBjC,EAAEmB,MAAMjB,MAAM0G,UAAY,cAAc5G,EAAE4B,aAG1C5B,EAAEkC,MAAQoE,uBAAuBO,GAAM7G,EAAEwG,KAAKK,IAC/C,CAED,eAAAF,GACE,OAAOV,OAAOa,YAAc7G,KAAKsB,WAAatB,KAAKoB,YAAcpB,KAAKqB,YACvE,CAED,YAAAsE,CAAaD,GACX,MAAM3F,EAAIC,KACe,IAArB0F,EAAEoB,QAAQ/B,SAEdhF,EAAE0B,YAAa,EACf1B,EAAE6B,WAAa8D,EAAEoB,QAAQ,GAAGC,QAC5BhH,EAAE8B,WAAa6D,EAAEoB,QAAQ,GAAGE,QAC5BjH,EAAE+B,YAAc/B,EAAE4B,QAClB5B,EAAE0C,eAAiB,EACnB1C,EAAE4D,OACH,CAED,WAAAkC,CAAYH,GACV,MAAM3F,EAAIC,KACV,IAAKD,EAAE0B,YAAmC,IAArBiE,EAAEoB,QAAQ/B,OAAc,OAG7C,GAAyB,IAArBhF,EAAE0C,eAAsB,CAC1BiD,EAAEuB,iBACF,MAAMC,EAAQxB,EAAEoB,QAAQ,GAAGC,QAAUhH,EAAE6B,WAGvC,IADA7B,EAAE4B,QAAU5B,EAAE+B,YAAcoF,EACrBnH,EAAE4B,UAAY5B,EAAEiC,cAAcjC,EAAE4B,SAAW5B,EAAEiC,aACpD,KAAOjC,EAAE4B,QAAU,GAAG5B,EAAE4B,SAAW5B,EAAEiC,aAErC,YADAjC,EAAEmB,MAAMjB,MAAM0G,UAAY,cAAc5G,EAAE4B,aAE3C,CAGD,MAAMwF,EAAS/B,KAAKgC,IAAIrH,EAAE6B,WAAa8D,EAAEoB,QAAQ,GAAGC,SAC9CM,EAASjC,KAAKgC,IAAIrH,EAAE8B,WAAa6D,EAAEoB,QAAQ,GAAGE,SAGpD,OACW,KAATG,EAAgBE,IACfF,EAASpH,EAAE2C,oBAAsB2E,EAAStH,EAAE2C,qBAG7C3C,EAAE0C,eAAiB,OACnBiD,EAAEuB,kBAEOI,EAAStH,EAAE2C,oBAAsByE,GAAUE,GAEpDtH,EAAE0C,gBAAkB,EACpB1C,EAAE0B,YAAa,OACV1B,EAAEyB,eAAezB,EAAEuD,eAK1BoC,EAAEuB,gBACH,CAED,UAAAnB,GACE,MAAM/F,EAAIC,KACLD,EAAE0B,aACP1B,EAAE0B,YAAa,EACf1B,EAAE0C,eAAiB,EACd1C,EAAEyB,eAAezB,EAAEuD,QACzB,CAED,aAAAyC,CAAcL,GACZ,MAAM3F,EAAIC,KAEY,UAAlB0F,EAAE4B,cAENvH,EAAE0B,YAAa,EACf1B,EAAE6B,WAAa8D,EAAE6B,QACjBxH,EAAE8B,WAAa6D,EAAE8B,QACjBzH,EAAE+B,YAAc/B,EAAE4B,QAClB5B,EAAE0C,eAAiB,EACnB1C,EAAE4D,OACF5D,EAAEmB,MAAMuG,kBAAkB/B,EAAEgC,WAC7B,CAED,aAAAzB,CAAcP,GACZ,MAAM3F,EAAIC,KACV,IAAKD,EAAE0B,WAAY,OAEnB,GAAsB,UAAlBiE,EAAE4B,YAAyB,OAG/B,MAAMJ,EAAQxB,EAAE6B,QAAUxH,EAAE6B,WAK5B,IAHA7B,EAAE4B,QAAU5B,EAAE+B,YAAcoF,EAGrBnH,EAAE4B,UAAY5B,EAAEiC,cAAcjC,EAAE4B,SAAW5B,EAAEiC,aACpD,KAAOjC,EAAE4B,QAAU,GAAG5B,EAAE4B,SAAW5B,EAAEiC,aAErCjC,EAAEmB,MAAMjB,MAAM0G,UAAY,cAAc5G,EAAE4B,YAC3C,CAED,WAAAuE,CAAYR,GACV,MAAM3F,EAAIC,KACV,GAAKD,EAAE0B,YAEe,UAAlBiE,EAAE4B,YAAN,CAEAvH,EAAE0B,YAAa,EACf1B,EAAE0C,eAAiB,EACnB,IACE1C,EAAEmB,MAAMyG,sBAAsBjC,EAAEgC,UACtC,CAAM,MAED,CACI3H,EAAEyB,eAAezB,EAAEuD,OATc,CAUvC,CAED,mBAAAlB,GACE,MAAMrC,EAAIC,KACVgD,YAAW,KAMT,IALAjD,EAAEgC,eAAiBhC,EAAE0E,wBAAwBC,MAC7C3E,EAAEqD,kBAGFrD,EAAE4B,QAAU5B,EAAE4B,QAAU5B,EAAEiC,aACnBjC,EAAE4B,UAAY5B,EAAEiC,cAAcjC,EAAE4B,SAAW5B,EAAEiC,aACpD,KAAOjC,EAAE4B,QAAU,GAAG5B,EAAE4B,SAAW5B,EAAEiC,aAErCjC,EAAEmB,MAAMjB,MAAM0G,UAAY,cAAc5G,EAAE4B,aAGrC5B,EAAEyB,eAAkBzB,EAAE0B,YACzB1B,EAAEuD,UAEH,EACJ,CAED,YAAAhB,GACE,MAAMvC,EAAIC,KACGD,EAAE0E,wBAAwBC,QAC1B3E,EAAEgC,gBACfhC,EAAEmC,mBACH,CAED,WAAAM,GACExC,KAAKkC,mBACN,EAEHxB,eAAeC,OAAO,oBAAqBG"}