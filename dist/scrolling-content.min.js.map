{"version":3,"file":"scrolling-content.min.js","sources":["../src/scrolling-content.js"],"sourcesContent":["// <scrolling-track>\nclass ScrollingTrack extends HTMLElement {\n  connectedCallback() {\n    this.style.display = 'flex';\n    this.style.flexWrap = 'nowrap';\n    this.style.alignItems = 'center';\n    this.style.gap = 'var(--scrolling-content-gap, 1rem)';\n    this.style.cursor = 'pointer';\n    this.style.touchAction = 'pan-y';\n    if (this.dataset.gap) this.style.gap = `${parseFloat(this.dataset.gap)}px`;\n  }\n}\ncustomElements.define('scrolling-track', ScrollingTrack);\n\n// <scrolling-item>\nclass ScrollingItem extends HTMLElement {\n  connectedCallback() {\n    this.style.display = 'flex';\n    this.style.alignItems = 'center';\n    this.style.gap = 'var(--scrolling-content-gap, 1rem)';\n    if (this.dataset.pad) this.style.padding = `${parseFloat(this.dataset.pad)}px`;\n  }\n}\ncustomElements.define('scrolling-item', ScrollingItem);\n\n// <scrolling-content>\nclass ScrollingContent extends HTMLElement {\n  static get observedAttributes() {\n    return ['data-mobile-speed', 'data-desktop-speed', 'data-breakpoint'];\n  }\n\n  constructor() {\n    super();\n    const _ = this;\n    _.track = null;\n    _.items = [];\n    _.mobileSpeed = 40;\n    _.desktopSpeed = 60;\n    _.breakpoint = 767;\n    _.isRunning = false;\n    _.isHoverPaused = false;\n    _.isDragging = false;\n    _.prevTime = 0;\n    _.offsetX = 0;\n    _.dragStartX = 0;\n    _.dragStartY = 0; // track initial Y position for direction detection\n    _.startOffset = 0;\n    _.containerWidth = 0;\n    _.loopDistance = 0; // distance to move before wrapping back to start\n    _.rafId = null;\n    _.resizeHandler = () => _.handleResize();\n    _.touchDirection = 0; // 0: unknown, 1: horizontal, -1: vertical\n    _.directionThreshold = 3; // pixels of movement before determining direction\n  }\n\n  connectedCallback() {\n    const _ = this;\n    _.initElements();\n    _.readAttributes();\n    requestAnimationFrame(() => {\n      _.checkTrackWidth();\n      _.attachEvents();\n      _.start();\n    });\n  }\n\n  attributeChangedCallback(name, oldV, newV) {\n    if (oldV === newV) return;\n    this.readAttributes();\n    if (!this.isHoverPaused && !this.isDragging) {\n      this.stop();\n      this.start();\n    }\n  }\n\n  initElements() {\n    const _ = this;\n    _.style.overflow = 'hidden';\n    _.track = _.querySelector('scrolling-track');\n    if (!_.track) {\n      _.track = document.createElement('scrolling-track');\n      while (_.firstChild) _.track.appendChild(_.firstChild);\n      _.appendChild(_.track);\n    }\n\n    // Check if content is already wrapped in scrolling-item\n    const existingItem = _.track.querySelector('scrolling-item');\n    if (!existingItem) {\n      // Wrap all track content in a single scrolling-item\n      const item = document.createElement('scrolling-item');\n      while (_.track.firstChild) {\n        item.appendChild(_.track.firstChild);\n      }\n      _.track.appendChild(item);\n    }\n\n    _.items = Array.from(_.track.children);\n    Object.assign(_.track.style, {\n      display: 'flex',\n      willChange: 'transform',\n    });\n    _.containerWidth = _.getBoundingClientRect().width;\n  }\n\n  readAttributes() {\n    const _ = this;\n    const getNum = (attr, fallback) =>\n      isNaN(parseFloat(_.getAttribute(attr))) ? fallback : parseFloat(_.getAttribute(attr));\n    _.mobileSpeed = getNum('data-mobile-speed', _.mobileSpeed);\n    _.desktopSpeed = getNum('data-desktop-speed', _.desktopSpeed);\n    _.breakpoint = getNum('data-breakpoint', _.breakpoint);\n  }\n\n  /**\n   * duplicates items until track is at least 200% of container width\n   */\n  checkTrackWidth() {\n    const _ = this;\n    if (!_.items.length) return;\n\n    // get the width of the first item (since all items are the same)\n    const itemWidth = _.items[0].getBoundingClientRect().width;\n\n    // get gap from CSS variable or track style\n    const computedStyle = getComputedStyle(_.track);\n    const gap = parseFloat(computedStyle.gap) || 0;\n\n    // store the distance we need to move before wrapping back to start\n    // this is the width of one item plus one gap\n    _.loopDistance = itemWidth + gap;\n\n    // calculate how many items we need to fill 200% of container\n    const itemsNeeded = Math.ceil((_.containerWidth * 2) / itemWidth) + 1;\n\n    // only duplicate if we need more items\n    const currentCount = _.items.length;\n    for (let i = currentCount; i < itemsNeeded; i++) {\n      const clone = _.items[0].cloneNode(true);\n      _.track.appendChild(clone);\n    }\n\n    // update items array with all children\n    _.items = Array.from(_.track.children);\n  }\n\n  attachEvents() {\n    const _ = this;\n    _.addEventListener('mouseenter', () => {\n      _.isHoverPaused = true;\n      _.stop();\n    });\n    _.addEventListener('mouseleave', () => {\n      _.isHoverPaused = false;\n      if (!_.isDragging) _.start();\n    });\n    \n    // Touch events for better mobile support\n    _.track.addEventListener('touchstart', (e) => _.onTouchStart(e), { passive: false });\n    _.track.addEventListener('touchmove', (e) => _.onTouchMove(e), { passive: false });\n    _.track.addEventListener('touchend', (e) => _.onTouchEnd(e));\n    _.track.addEventListener('touchcancel', (e) => _.onTouchEnd(e));\n    \n    // Pointer events for desktop/mouse\n    _.track.addEventListener('pointerdown', (e) => _.onPointerDown(e));\n    window.addEventListener('pointermove', (e) => _.onPointerMove(e));\n    window.addEventListener('pointerup', (e) => _.onPointerUp(e));\n    window.addEventListener('pointercancel', (e) => _.onPointerUp(e));\n    window.addEventListener('resize', _.resizeHandler);\n  }\n\n  start() {\n    const _ = this;\n    if (_.isRunning) return;\n    _.isRunning = true;\n    _.prevTime = performance.now();\n    _.rafId = requestAnimationFrame((ts) => _.tick(ts));\n  }\n\n  stop() {\n    const _ = this;\n    if (!_.isRunning) return;\n    cancelAnimationFrame(_.rafId);\n    _.isRunning = false;\n    _.rafId = null;\n  }\n\n  /**\n   * main animation loop\n   * @param {number} ts - timestamp from requestAnimationFrame\n   */\n  tick(ts) {\n    const _ = this;\n    if (!_.isRunning) return;\n\n    // calculate time delta\n    const delta = (ts - _.prevTime) / 1000;\n    _.prevTime = ts;\n\n    // move left by speed * delta\n    _.offsetX -= _.getCurrentSpeed() * delta;\n\n    // wrap around when we've moved past one complete loop distance\n    // this creates the infinite loop illusion\n    if (_.offsetX <= -_.loopDistance) {\n      _.offsetX += _.loopDistance;\n    }\n\n    // apply the transform\n    _.track.style.transform = `translateX(${_.offsetX}px)`;\n\n    // continue animation\n    _.rafId = requestAnimationFrame((t) => _.tick(t));\n  }\n\n  getCurrentSpeed() {\n    return window.innerWidth <= this.breakpoint ? this.mobileSpeed : this.desktopSpeed;\n  }\n\n  onTouchStart(e) {\n    const _ = this;\n    if (e.touches.length !== 1) return; // only handle single touch\n    \n    _.isDragging = true;\n    _.dragStartX = e.touches[0].screenX;\n    _.dragStartY = e.touches[0].screenY;\n    _.startOffset = _.offsetX;\n    _.touchDirection = 0; // reset direction\n    _.stop();\n  }\n\n  onTouchMove(e) {\n    const _ = this;\n    if (!_.isDragging || e.touches.length !== 1) return;\n\n    // if already determined to be horizontal, prevent default and scroll\n    if (_.touchDirection === 1) {\n      e.preventDefault();\n      const diffX = e.touches[0].screenX - _.dragStartX;\n      \n      _.offsetX = _.startOffset + diffX;\n      while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n      while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n      _.track.style.transform = `translateX(${_.offsetX}px)`;\n      return;\n    }\n\n    // calculate movement distances to determine direction\n    const deltaX = Math.abs(_.dragStartX - e.touches[0].screenX);\n    const deltaY = Math.abs(_.dragStartY - e.touches[0].screenY);\n\n    // determine direction with bias toward horizontal (like your carousel)\n    if (deltaX * 1.15 > deltaY && (deltaX > _.directionThreshold || deltaY > _.directionThreshold)) {\n      // horizontal movement detected\n      _.touchDirection = 1;\n      e.preventDefault();\n      return;\n    } else if (deltaY > _.directionThreshold && deltaX <= deltaY) {\n      // vertical movement detected - cancel drag and allow page scroll\n      _.touchDirection = -1;\n      _.isDragging = false;\n      if (!_.isHoverPaused) _.start();\n      return;\n    }\n\n    // direction not yet determined - prevent default to avoid premature page scroll\n    e.preventDefault();\n  }\n\n  onTouchEnd(e) {\n    const _ = this;\n    if (!_.isDragging) return;\n    _.isDragging = false;\n    _.touchDirection = 0;\n    if (!_.isHoverPaused) _.start();\n  }\n\n  onPointerDown(e) {\n    const _ = this;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n    \n    _.isDragging = true;\n    _.dragStartX = e.clientX;\n    _.dragStartY = e.clientY; // store initial Y position\n    _.startOffset = _.offsetX;\n    _.touchDirection = 0; // reset direction detection\n    _.stop();\n    _.track.setPointerCapture(e.pointerId);\n  }\n\n  onPointerMove(e) {\n    const _ = this;\n    if (!_.isDragging) return;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n\n    // calculate movement distances\n    const diffX = e.clientX - _.dragStartX;\n    const diffY = e.clientY - _.dragStartY;\n\n    _.offsetX = _.startOffset + diffX;\n\n    // normalize offset to stay within bounds\n    while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n    while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n\n    _.track.style.transform = `translateX(${_.offsetX}px)`;\n  }\n\n  onPointerUp(e) {\n    const _ = this;\n    if (!_.isDragging) return;\n    // Skip if this is a touch event (handled by touch handlers)\n    if (e.pointerType === 'touch') return;\n    \n    _.isDragging = false;\n    _.touchDirection = 0; // reset direction\n    try {\n      _.track.releasePointerCapture(e.pointerId);\n    } catch {\n      // Ignore errors if pointer capture was already released\n    }\n    if (!_.isHoverPaused) _.start();\n  }\n\n  handleResize() {\n    const _ = this;\n    const newW = _.getBoundingClientRect().width;\n    if (newW === _.containerWidth) return;\n    _.containerWidth = newW;\n\n    // recalculate and rebuild track\n    _.checkTrackWidth();\n\n    // normalize offset position\n    _.offsetX = _.offsetX % _.loopDistance;\n    while (_.offsetX <= -_.loopDistance) _.offsetX += _.loopDistance;\n    while (_.offsetX > 0) _.offsetX -= _.loopDistance;\n\n    _.track.style.transform = `translateX(${_.offsetX}px)`;\n  }\n}\ncustomElements.define('scrolling-content', ScrollingContent);\n"],"names":["ScrollingTrack","HTMLElement","connectedCallback","this","style","display","flexWrap","alignItems","gap","cursor","touchAction","dataset","parseFloat","customElements","define","ScrollingItem","pad","padding","ScrollingContent","observedAttributes","constructor","super","_","track","items","mobileSpeed","desktopSpeed","breakpoint","isRunning","isHoverPaused","isDragging","prevTime","offsetX","dragStartX","dragStartY","startOffset","containerWidth","loopDistance","rafId","resizeHandler","handleResize","touchDirection","directionThreshold","initElements","readAttributes","requestAnimationFrame","checkTrackWidth","attachEvents","start","attributeChangedCallback","name","oldV","newV","stop","overflow","querySelector","document","createElement","firstChild","appendChild","item","Array","from","children","Object","assign","willChange","getBoundingClientRect","width","getNum","attr","fallback","isNaN","getAttribute","length","itemWidth","computedStyle","getComputedStyle","itemsNeeded","Math","ceil","i","clone","cloneNode","addEventListener","e","onTouchStart","passive","onTouchMove","onTouchEnd","onPointerDown","window","onPointerMove","onPointerUp","performance","now","ts","tick","cancelAnimationFrame","delta","getCurrentSpeed","transform","t","innerWidth","touches","screenX","screenY","preventDefault","diffX","deltaX","abs","deltaY","pointerType","clientX","clientY","setPointerCapture","pointerId","releasePointerCapture","newW"],"mappings":"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"}